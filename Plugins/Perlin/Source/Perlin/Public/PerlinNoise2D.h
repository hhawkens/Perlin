#pragma once

#include "CoreMinimal.h"

/**
 * An octave is storing a set number of time-value points on a float curve
 * with more points the more octaves there are. The perlin values will be retrieved
 * by cubic interpolation of the values between those points.
 * Key = time(x-Axis), Value = constant perlin value(y-Axis)
 */
using FOctave = TMap<float, float>;


/**
 * Generates a 2D Perlin function that emits a connected stream
 * of random numbers in given range(curve). It operates along a
 * time line that ranges from 0 to 1, and creates a new curve
 * when it reaches the end
 */
class PERLIN_API FPerlinNoise2D
{

public:

	FPerlinNoise2D(uint8 OctaveCount = 4, uint8 StartingOctave = 0, float Min = 0.f, float Max = 1.f);


public:

	/** Get the current point in time to get the Perlin value from (0-1)*/
	FORCEINLINE float GetCurrentTimePoint() const { return CurrentTime; }

	/** Set highest value generated by noise */
	FORCEINLINE void SetMax(float Value) { Max = Value; }

	/** Set lowest value generated by noise */
	FORCEINLINE void SetMin(float Value) { Min = Value; }

	/** Set which octave to start computation at. Usually 0, higher value means more curved product */
	FORCEINLINE void SetStartingOctave(uint8 Value) { StartingOctave = FMath::Clamp<uint8>(Value, 0, Value); }

	/** Set number of samples. Higher count means smoother curve */
	FORCEINLINE void SetOctaveCount(uint8 Value) { OctaveCount = FMath::Clamp<uint8>(Value, 0, Value); }

	/** Set the weight for first octave, usually 0.5. Decreasing with each subsequent curve */
	FORCEINLINE void SetBaseAmplitude(float Value) { BaseAmplitude = FMath::Clamp(Value, 0.f, 1.f); }

	/** Set the point in time to get the Perlin value from (0-1)*/
	FORCEINLINE void SetCurrentTime(float Value) { CurrentTime = FMath::Clamp(Value, 0.f, 1.f); }

	/** When a new curve is generated, set whether to use the previous curve's end the starting point? */
	FORCEINLINE void SetContinuousCurve(bool Value) { bContinuousCurve = Value; }


public:

	/** Create several curves for random number generation, each new curve with less weight */
	void GenerateOctaves();

	/**
	 * Get value along curves at point CurrentTime + @param Time in timeline.
	 * Automatically creates new curve when timeline exceeds 1 or isn't
	 * initialized yet.
	 * @param bAdvanceTime makes CurrentTime play forward by the amount of time
	 */
	float GetPerlinValue(float Time, bool bAdvanceTime = true);


protected:

	/**
	 * Return the current curve's values for each octave at timeline = 1
	 * Used to seamlessly continue the newly created curve
	 */
	TArray<float> GetOctavesLastValues() const;


protected:

	/** Highest value generated by noise */
	float Max;

	/** Lowest value generated by noise */
	float Min;

	/** Which octave to start computation at. Usually 0, higher value means more curved */
	uint8 StartingOctave;

	/** Number of samples. Higher count means smoother curve */
	uint8 OctaveCount;

	/** Determines the weight for each octave, usually 0.5. Decreasing with each subsequent curve */
	float BaseAmplitude;

	/** Whenever a new curve is generated, use the previous curve's end as starting point? */
	bool bContinuousCurve;


protected:

	/** Cumulative time line accessing the curve */
	float CurrentTime;

	/** Stored octaves and their values */
	TArray<FOctave> Octaves;
};
